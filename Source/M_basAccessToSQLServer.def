Option Compare Database
Option Explicit

Public Enum TipoArreglo
    Cambio_tamaño_campo = 1 ' Sólo campos de texto, Arreglo= NombreCampo,NuevoTamaño
    Eliminar_campo = 2 ' Arreglo = NombreCampo
    Añadir_campo = 3 'Arreglo = NombreCampo,TipoDato,[Tamaño]
    Eliminar_indice = 4 'Arreglo = NombreIndice
    Añadir_indice = 5 'Arreglo = NombreIndice,PrimaryKeySN,UniqueSN,Campo1;Campo2;...
    Eliminar_relacion = 6 'Arreglo = NombreRelacion, ForeignTable, CampoClave
    Añadir_relacion = 7 'Arreglo = NombreRelacion,CampoFK, Reference_Table, Reference_Field, OnUpdateCascadeSN, OnDeleteCascadeSN
End Enum

Public Type SQLdb
    Server As String
    DBname As String
    User As String
    Password As String
End Type

Public Function GetDBfromFile(lIdAccessDB As Long _
             , Optional ByRef sServer As String _
             , Optional ByRef sDatabase As String _
             , Optional ByRef sUser As String _
             , Optional ByRef sPassword As String _
             , Optional ByRef sDBPath As String) As Database
    On Error GoTo HandleError
    Dim sBasePath As String, sAdbPath As String
    Dim lIdMigration As Long
    lIdMigration = DLookup("IdMigration", "tbAccessDBs", "Id = " & lIdAccessDB)
    sServer = DLookup("TargetServer", "tbMigrations", "Id = " & lIdMigration)
    sDatabase = DLookup("TargetDB", "tbMigrations", "Id = " & lIdMigration)
    sUser = DLookup("User", "tbMigrations", "Id = " & lIdMigration)
    sPassword = DLookup("Pass", "tbMigrations", "Id = " & lIdMigration)
    sBasePath = Nz(DLookup("Carpeta", "tbMigrations", "Id = " & lIdMigration), "")
    If sBasePath = "" Then
        MsgBox "Se debe indicar carpeta base de la Migración", vbExclamation
        GoTo HandleExit
    End If
    sAdbPath = Nz(DLookup("[Path] & [FileName]", "tbAccessDBs", "Id = " & lIdAccessDB), "")
    sDBPath = sBasePath & sAdbPath
    Set GetDBfromFile = OpenDatabase(sDBPath, , True)
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function


Public Function GenerarTSQLEstructuraTabla(db As DAO.Database, sTabla As String) As String
    
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'Septiembre 2024
    'Lorenzo - Abauntz Software + ChatGPT
    'Devuelve la sentencia TSQL para generar las tablas de la base de datos incluidas en la lista: tabla1,tabla2,tabla3''''''''''
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    On Error GoTo HandleError
    Dim tdf As DAO.TableDef
    Dim fld As DAO.Field
    Dim idx As DAO.Index
    Dim rel As DAO.Relation
    Dim strSQL As String
    Dim strTableSQL As String
    Dim strFieldSQL As String
    Dim i As Integer
    Dim fieldCount As Integer
    Dim sResult As String
        
    Set tdf = db.TableDefs(Trim(sTabla))
    strTableSQL = "IF OBJECT_ID('dbo." & tdf.Name & "', 'U') IS NOT NULL" _
       & vbCrLf & "DROP TABLE dbo." & tdf.Name & ";" _
       & vbCrLf & "CREATE TABLE " & tdf.Name & " (" & vbCrLf
    strFieldSQL = ""
    fieldCount = 0
    
    ' Recorrer todos los campos de la tabla
    For Each fld In tdf.Fields
        ' Obtener el nombre del campo y su tipo de dato
        If (fld.Attributes And dbAutoIncrField) <> 0 Then
        ' Si es un campo autonumérico, utilizar INT IDENTITY
            strFieldSQL = "[" & fld.Name & "] INT IDENTITY(1,1)"
        Else
            strFieldSQL = "[" & fld.Name & "] " & AccessToSQLDataType(fld.Type, fld.Size)
        End If
        
        ' Si es un campo con clave primaria, añadir la restricción
        For Each idx In tdf.Indexes
            If idx.Primary And fld.Name = idx.Fields(0).Name Then
                strFieldSQL = strFieldSQL & " PRIMARY KEY"
                Exit For
            End If
        Next idx
        
        ' Añadir coma entre campos (menos en el último)
        If fieldCount > 0 Then
            strTableSQL = strTableSQL & ", " & vbCrLf
        End If
        
        strTableSQL = strTableSQL & strFieldSQL
        fieldCount = fieldCount + 1
    Next fld
    
    ' Cerrar la instrucción CREATE TABLE
    strTableSQL = strTableSQL & vbCrLf & ");" & vbCrLf & vbCrLf
    
    ' Mostrar el comando SQL generado (o enviarlo a SQL Server)
    Debug.Print strTableSQL
    GenerarTSQLEstructuraTabla = strTableSQL
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function

Public Function GenerarTSQLRelaciones(db As DAO.Database) As String
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'Septiembre 2024
    'Lorenzo - Abauntz Software + ChatGPT
    'Devuelve la sentencia TSQL para generar las relaciones entre tablas de la base de datos, diferenciando relaciones lógicas
    'de relaciones con integridad referencial, y eliminando las claves foráneas preexistentes.
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

    On Error GoTo HandleError
    Dim rel As DAO.Relation
    Dim fld As DAO.Field
    Dim strSQL As String, sResult As String
    Dim foreignKeySQL As String
    Dim hasReferentialIntegrity As Boolean
    Dim constraintName As String
    
    ' Recorrer todas las relaciones en la base de datos
    For Each rel In db.Relations
        If rel.Name Like "MSys*" Then
        Else
            ' Verificar si la relación tiene integridad referencial
            hasReferentialIntegrity = False
            If (rel.Attributes And dbRelationUnique) Or (rel.Attributes And dbRelationUpdateCascade) Or (rel.Attributes And dbRelationDeleteCascade) Then
                hasReferentialIntegrity = True
            End If
            
            ' Generar el nombre de la clave foránea
            constraintName = "FK_" & rel.ForeignTable & "_" & rel.Table
            
            ' Verificar si la relación ya existe, y si es así, eliminarla
            
            ' Generar la instrucción SQL para la clave foránea si tiene integridad referencial
            sResult = sResult & vbCrLf & constraintName
            If hasReferentialIntegrity Then
                foreignKeySQL = "IF EXISTS (SELECT 1 FROM sys.foreign_keys WHERE name = '" & constraintName & "') " & vbLf & _
                                "BEGIN " & vbLf & _
                                "    ALTER TABLE " & rel.ForeignTable & " DROP CONSTRAINT " & constraintName & ";" & vbLf & _
                                "END;" & vbLf
                foreignKeySQL = foreignKeySQL & "ALTER TABLE " & rel.ForeignTable & " ADD CONSTRAINT " & constraintName & _
                                " FOREIGN KEY (" & rel.Fields(0).ForeignName & ") REFERENCES " & rel.Table & " (" & rel.Fields(0).Name & ")"
                
                ' Agregar las opciones CASCADE si es necesario
                If (rel.Attributes And dbRelationUpdateCascade) Then
                    foreignKeySQL = foreignKeySQL & " ON UPDATE CASCADE"
                End If
                If (rel.Attributes And dbRelationDeleteCascade) Then
                    foreignKeySQL = foreignKeySQL & " ON DELETE CASCADE"
                End If
                foreignKeySQL = foreignKeySQL & ";"
                
                ' Añadir la sentencia a la salida
                sResult = sResult & vbCrLf & foreignKeySQL
            Else
                ' Para relaciones que no impliquen integridad referencial, simplemente ignóralas o genera un comentario
                sResult = sResult & vbCrLf & "-- Relación sin integridad referencial: " & rel.Name
            End If
        End If
    Next rel
    
    If Len(sResult) > 2 Then sResult = Mid(sResult, 3)
    GenerarTSQLRelaciones = sResult

HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function


Public Function GenerarTSQLEliminarRelaciones() As String
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'Septiembre 2024
    'Lorenzo - Abauntz Software + ChatGPT
    'Devuelve la sentencia TSQL para eliminar todas las relaciones entre tablas de una base de datos'''''''''''''''''''''''''''''
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    On Error GoTo HandleError
    Dim sResult As String
    sResult = "DECLARE @sql NVARCHAR(MAX) = N'';" & vbCrLf _
            & "-- Genera las sentencias ALTER TABLE para eliminar todas las claves foráneas" & vbCrLf _
            & "SELECT @sql += 'ALTER TABLE [' + OBJECT_SCHEMA_NAME(parent_object_id) + '].[' + OBJECT_NAME(parent_object_id) + '] DROP CONSTRAINT [' + name + '];' + CHAR(13)" & vbCrLf _
            & "FROM sys.foreign_keys;" & vbCrLf _
            & "-- Ejecuta las sentencias generadas" & vbCrLf _
            & "EXEC sp_executesql @sql;"

    
    GenerarTSQLEliminarRelaciones = sResult
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function



Public Function GenerarTSQLEliminarIndices(sTabla As String) As String
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'Septiembre 2024
    'Lorenzo - Abauntz Software + ChatGPT
    'Devuelve la sentencia TSQL para eliminar todas las relaciones entre tablas de una base de datos'''''''''''''''''''''''''''''
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    On Error GoTo HandleError
    Dim sResult As String

    sResult = "DECLARE @TableName NVARCHAR(256) = '" & sTabla & "'" & vbCrLf _
            & "DECLARE @SQL NVARCHAR(MAX) = '';" & vbCrLf _
            & "-- Genera las sentencias DROP INDEX para todos los índices de la tabla" & vbCrLf _
            & "SELECT @SQL = @SQL + 'DROP INDEX ' + QUOTENAME(i.name) + ' ON ' + QUOTENAME(t.name) + '; ' + CHAR(13)" & vbCrLf _
            & "FROM sys.indexes i JOIN sys.tables t ON i.object_id = t.object_id" & vbCrLf _
            & "WHERE i.type > 0  -- Excluye índices especiales como índices de clave primaria y únicos" & vbCrLf _
            & "AND t.name = @TableName;" & vbCrLf _
            & "-- Ejecuta las sentencias generadas" & vbCrLf _
            & "EXEC sp_executesql @SQL;"
    
    GenerarTSQLEliminarIndices = sResult
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function



Public Function GenerarTSQLIndices(db As DAO.Database _
                                , tblName As String) As String
    On Error GoTo HandleError
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'Septiembre 2024
    'Lorenzo - Abauntz Software + ChatGPT
    'Devuelve las sentencias TSQL para generar todos las índices de una tabla en una lista:         '''''''''''''''''''''''''''''
    '                                                       separador |: sentencia 1|sentencia 2|etc'''''''''''''''''''''''''''''
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

    Dim tdf As DAO.TableDef
    Dim idx As DAO.Index
    Dim fld As DAO.Field
    Dim tsql As String, sResult As String
    Dim indiceCampos As String
    Dim isUnique As String
    
    
    ' Obtener la definición de la tabla
    Set tdf = db.TableDefs(tblName)
    
    ' Recorrer los índices de la tabla
    For Each idx In tdf.Indexes
        indiceCampos = ""  ' Inicializar para cada índice
        
        ' Verificar si el índice es único
        If idx.Unique Then
            isUnique = "UNIQUE "
        Else
            isUnique = ""
        End If
        
        ' Recorrer los campos del índice
        For Each fld In idx.Fields
            If indiceCampos <> "" Then
                indiceCampos = indiceCampos & ", "
            End If
            indiceCampos = indiceCampos & "[" & fld.Name & "]"
        Next fld
        
        ' Generar la sentencia T-SQL para el índice
        tsql = "CREATE " & isUnique & "INDEX [" & idx.Name & "] ON [" & tblName & "] (" & indiceCampos & ");"
        
        ' Mostrar o exportar el T-SQL generado
        Debug.Print tsql
        sResult = sResult & vbCrLf & "-- " & idx.Name & ": " & vbCrLf & tsql
    Next idx
    If Len(sResult) > 2 Then sResult = Mid(sResult, 3)
    GenerarTSQLIndices = sResult
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function


Function AccessToSQLDataType(AccessType As Integer, FieldSize As Long) As String
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'Septiembre 2024
    'Lorenzo - Abauntz Software + ChatGPT
    'Devuelve el nombre del tipo de campo para SQL Server correspondiente al de Access pasado en el parámetro''''''''''''''''''''
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    On Error GoTo HandleError
    Select Case AccessType
        Case dbText
            AccessToSQLDataType = "NVARCHAR(" & FieldSize & ")"
        Case dbMemo
            AccessToSQLDataType = "TEXT"
        Case dbLong
            AccessToSQLDataType = "INT"
        Case dbInteger
            AccessToSQLDataType = "SMALLINT"
        Case dbSingle
            AccessToSQLDataType = "REAL"
        Case dbDouble
            AccessToSQLDataType = "FLOAT"
        Case dbCurrency
            AccessToSQLDataType = "MONEY"
        Case dbDate
            AccessToSQLDataType = "DATETIME"
        Case dbBoolean
            AccessToSQLDataType = "BIT"
        Case Else
            AccessToSQLDataType = "NVARCHAR(255)" ' Por defecto, usamos NVARCHAR
    End Select
    
    
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function

Public Function TraspasaDatosTabla(lIdTabla As Long _
                        , Optional batchSize As Integer = 100 _
                        , Optional ByRef lNumRegistros As Long _
                        , Optional iRunSQL_ToText As Integer = 1 _
                        , Optional sSQL_R As String) As Boolean
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'Septiembre 2024
    'Lorenzo - Abauntz Software + ChatGPT
    'Genera SQL para migración de datos y ejecuta la SQL en bloques de batchSize Registros'''''''''''''''''''''''''''''''''''''
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    
    On Error GoTo HandleError
    Dim db As DAO.Database
    Dim rs As DAO.Recordset
    Dim td As DAO.TableDef
    Dim fld As DAO.Field
    Dim strSQL As String
    Dim strInsert As String
    Dim strFields As String
    Dim strValues As String
    Dim i As Integer, j As Integer, batchCount As Integer, iR As Integer

    Dim lIdAccessDB As Long, sTableName As String, sSQL As String, lRegistrosAfectados As Long, lTotalRegistrosAfectados As Long
    Dim sTargetServer As String, sTargetDB As String, sUser As String, sPass As String, bHasAutonum As Boolean
    lIdAccessDB = DLookup("IdAccessDB", "tbTablas", "Id = " & lIdTabla)
    sTableName = DLookup("TableName", "tbTablas", "Id = " & lIdTabla)
    bHasAutonum = InStr(DLookup("TSQL", "tbTablas", "Id = " & lIdTabla), "INT IDENTITY(1,1)") > 0
    Set db = GetDBfromFile(lIdAccessDB, sTargetServer, sTargetDB, sUser, sPass)
    Set rs = db.OpenRecordset(sTableName, dbOpenSnapshot)
    ' Recorrer todos los registros de la tabla
    If Not rs.EOF Then
        rs.MoveLast
        rs.MoveFirst
        'iR = MsgBox("¿Traspasar " & rs.RecordCount & " registros de la tabla " & sTableName & "?", vbOKCancel + vbQuestion)
        iR = vbOK
        If iR = vbCancel Then GoTo HandleExit
    End If
    batchCount = 0
    DoEvents
'    '-- Habilitar IDENTITY_INSERT para la tabla
'    RunTSQL "SET IDENTITY_INSERT " & sTableName & " ON;", sTargetServer, sTargetDB, sUser, sPass

    Do Until rs.EOF
        strInsert = IIf(bHasAutonum, "SET IDENTITY_INSERT " & sTableName & " ON;" & vbCrLf, "") _
                  & "INSERT INTO " & sTableName & " ("

        For i = 0 To rs.Fields.Count - 1
            strInsert = strInsert & "[" & rs.Fields(i).Name & "],"
        Next i
        
        strInsert = Left(strInsert, Len(strInsert) - 1) & ") VALUES "

        For i = 1 To batchSize
            If rs.EOF Then Exit For
            
            strValues = "("
            For j = 0 To rs.Fields.Count - 1
                If IsNull(rs.Fields(j).Value) Then
                    strValues = strValues & "NULL,"
                ElseIf rs.Fields(j).Type = dbText Or rs.Fields(j).Type = dbMemo Then
                    strValues = strValues & "'" & Replace(rs.Fields(j).Value, "'", "''") & "',"
                ElseIf rs.Fields(j).Type = dbDate Then
                    If rs.Fields(j).Value < #1/1/1753# Or rs.Fields(j).Value > #12/31/9999# Then
                        ' Si está fuera del rango, usamos NULL o una fecha por defecto
                        strValues = strValues & "NULL,"
                    Else
                        strValues = strValues & "CONVERT(DATETIME, '" & Format(rs.Fields(j).Value, "yyyy-mm-dd hh:nn:ss") & "',120),"
                    End If
                ElseIf rs.Fields(j).Type = dbBoolean Then
                    strValues = strValues & IIf(rs.Fields(j).Value = True, 1, 0) & ","
                Else
                    strValues = strValues & Replace(CStr(rs.Fields(j).Value), ",", ".") & ","
                End If
            Next j

            strValues = Left(strValues, Len(strValues) - 1) & "),"
            strInsert = strInsert & strValues
            rs.MoveNext
            lNumRegistros = lNumRegistros + 1
        Next i

        strInsert = Left(strInsert, Len(strInsert) - 1) & ";"
        strInsert = strInsert & IIf(bHasAutonum, vbCrLf & "SET IDENTITY_INSERT " & sTableName & " OFF;", "")
        lRegistrosAfectados = 0
        
        If iRunSQL_ToText = 1 Then
            RunTSQL strInsert, sTargetServer, sTargetDB, sUser, sPass, lRegistrosAfectados
            lTotalRegistrosAfectados = lTotalRegistrosAfectados + lRegistrosAfectados
        Else
            sSQL_R = sSQL_R & strInsert & vbCrLf
        End If
        batchCount = batchCount + 1
        If batchCount Mod 10 = 0 Then
            Debug.Print "Procesados " & lTotalRegistrosAfectados & " registros."
            MensajeBusyBox "Procesados " & lNumRegistros & " registros / " & rs.RecordCount, "Migrar Tabla " & sTableName, , True
            DoEvents
        End If
    Loop
        
    rs.Close
'    '-- Deshabilitar IDENTITY_INSERT para la tabla
'    RunTSQL "SET IDENTITY_INSERT " & sTableName & " OFF;", sTargetServer, sTargetDB, sUser, sPass

    Debug.Print "Total registros " & sTableName & ": " & lNumRegistros
    CurrentDb.Execute "UPDATE tbTablas SET NumRegistros = " & lNumRegistros & " WHERE Id = " & lIdTabla, dbFailOnError
    TraspasaDatosTabla = True
    'MsgBox "OK: Total registros afectados" & sTableName & ": " & lTotalRegistrosAfectados, vbInformation
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function



Public Function RunTSQL(sSQL As String _
                    , sServer As String _
                    , sDBname As String _
                    , sUser As String _
                    , sPass As String _
     , Optional ByRef lRegistrosAfectados As Long _
           , Optional bMsg As Boolean = False) As Boolean
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    'Septiembre 2024
    'Lorenzo - Abauntz Software + ChatGPT
    'Ejecuta sentencia TSQL, devuelve true si no hay error en la ejecución y Nº de registros afectados si es el caso'''''''''''''
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    On Error GoTo HandleError
    Dim conn As ADODB.Connection
    Dim strConn As String

    ' Cadena de conexión sin ODBC (OLE DB)
    strConn = "Provider=SQLOLEDB" _
            & ";Data Source=" & sServer _
            & ";Initial Catalog=" & sDBname _
            & ";User ID=" & sUser _
            & ";Password=" & sPass & ";"
    
    ' Crear la conexión ADO
    Set conn = New ADODB.Connection
    
    ' Abrir la conexión
    conn.Open strConn
    
    If conn.State = adStateOpen Then
        'MsgBox "Conexión exitosa a SQL Server"
    Else
        MsgBox "Error en la conexión"
        GoTo HandleExit
    End If
    
    ' Ejecutar el comando SQL
    conn.Execute sSQL, lRegistrosAfectados
    RunTSQL = True
    If bMsg Then MsgBox "Se ejecutó correctamente la SQL", vbInformation
    
HandleExit:
    ' Cerrar la conexión
    On Error Resume Next
    If Not conn Is Nothing Then conn.Close
    Set conn = Nothing
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function

Public Function GetCredencialesDB(lIdMigration As Long) As SQLdb
    On Error GoTo HandleError
    Dim SQLdbTo As SQLdb
    SQLdbTo.Server = Nz(DLookup("TargetServer", "tbMigrations", "Id = " & lIdMigration))
    SQLdbTo.DBname = Nz(DLookup("TargetDB", "tbMigrations", "Id = " & lIdMigration))
    SQLdbTo.User = Nz(DLookup("User", "tbMigrations", "Id = " & lIdMigration))
    SQLdbTo.Password = Nz(DLookup("Pass", "tbMigrations", "Id = " & lIdMigration))
    GetCredencialesDB = SQLdbTo
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function
Public Sub MigrarTabla(lIdTabla As Long _
            , Optional bCREATE As Boolean = True _
            , Optional bINSERT As Boolean = True _
            , Optional bINDEXES As Boolean = True _
            , Optional bForzarNuevosSQLs As Boolean = True _
            , Optional iRunSQL_ToText As Integer = 1 _
            , Optional sSQL_R As String)
    On Error GoTo HandleError
    Dim sSQL As String, SQLdbTo As SQLdb, bOK As String, sBasePath As String, sFilePath As String, db As DAO.Database, sTabla As String
    Dim lIdMigration As Long, lIdAccessDB As Long, sMsg As String, rs As Recordset, vTSQLs As Variant, i As Integer, item As Variant, lNumRegistros As Long
    lIdAccessDB = DLookup("IdAccessDB", "tbTablas", "Id = " & lIdTabla)
    lIdMigration = DLookup("IdMigration", "tbAccessDBs", "Id = " & lIdAccessDB)
    SQLdbTo = GetCredencialesDB(lIdMigration)
    
    sBasePath = DLookup("Carpeta", "tbMigrations", "Id = " & lIdMigration)
    sFilePath = DLookup("[Path] & [FileName]", "tbAccessDBs", "Id = " & lIdAccessDB)
    sFilePath = sBasePath & sFilePath
    sTabla = DLookup("TableName", "tbTablas", "Id = " & lIdTabla)
    Set db = OpenDatabase(sFilePath, , True)
CREATE_TABLE:
    If Not bCREATE Then GoTo INSERT_VALUES
    sSQL = Nz(DLookup("TSQL", "tbTablas", "Id = " & lIdTabla), "")
    If sSQL = "" Or bForzarNuevosSQLs Then
        sSQL = GenerarTSQLEstructuraTabla(db, sTabla)
        CurrentDb.Execute "UPDATE tbTablas SET TSQL = """ & sSQL & """ WHERE Id =" & lIdTabla, dbFailOnError
    End If
    If iRunSQL_ToText = 1 Then
        bOK = RunTSQL(sSQL, SQLdbTo.Server, SQLdbTo.DBname, SQLdbTo.User, SQLdbTo.Password)
        If bOK Then
            sMsg = sMsg & "Se creó la tabla " & sTabla & " correctamente - OK" & vbCrLf
        Else
            sMsg = sMsg & "No se creó la tabla " & sTabla & " - ERROR" & vbCrLf
        End If
    Else
        'Escribir a fichero
        sSQL_R = sSQL_R & sSQL & vbCrLf
    End If
    MensajeBusyBox sMsg, "Migrar Tabla " & sTabla, , True
INSERT_VALUES:
    If Not bINSERT Then GoTo CREATE_INDEXES
    TraspasaDatosTabla lIdTabla, 100, lNumRegistros, iRunSQL_ToText, sSQL_R
    MensajeBusyBox sMsg, lNumRegistros & " insertados en " & sTabla, , True
CREATE_INDEXES:
    If Not bINDEXES Then GoTo Finish
    Set rs = CurrentDb.OpenRecordset("SELECT * FROM tbIndices WHERE IdTabla = " & lIdTabla, dbOpenSnapshot)
    If rs.EOF Or bForzarNuevosSQLs Then
        CurrentDb.Execute "DELETE * FROM tbIndices WHERE IdTabla = " & lIdTabla, dbFailOnError
        sSQL = GenerarTSQLIndices(db, sTabla) 'Se reciben idxname1 & vbcrlf & TSQL1 & vbcrlf & idxname2 etc...
        vTSQLs = Split(sSQL, vbCrLf)
        For i = 0 To UBound(vTSQLs) - 1 Step 2
            CurrentDb.Execute "INSERT INTO tbIndices (IdTabla,Indice,TSQL) VALUES(" _
                                                                        & lIdTabla _
                                                                        & ", '" & vTSQLs(i) & "'" _
                                                                        & ", '" & vTSQLs(i + 1) & "')", dbFailOnError
        Next i
        Set rs = CurrentDb.OpenRecordset("SELECT * FROM tbIndices WHERE IdTabla = " & lIdTabla, dbOpenSnapshot)
    End If
    While Not rs.EOF
        If iRunSQL_ToText = 1 Then
            bOK = RunTSQL(rs("TSQL"), SQLdbTo.Server, SQLdbTo.DBname, SQLdbTo.User, SQLdbTo.Password)
            If bOK Then
                sMsg = sMsg & "Se creó el índice " & rs("Indice") & " de la tabla " & sTabla & " correctamente - OK" & vbCrLf
            Else
                sMsg = sMsg & "No se creó el índice " & rs("Indice") & " de la tabla " & sTabla & " - ERROR" & vbCrLf
            End If
        Else
            sSQL_R = sSQL_R & rs("TSQL") & vbCrLf
        End If
        MensajeBusyBox sMsg, "Migrar Tabla " & sTabla & " - Índices", , True
        rs.MoveNext
    Wend
Finish:
    MensajeBusyBox "", "MigrarTabla " & sTabla & " - Finalizado", True, True
    
HandleExit:
    Exit Sub
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Sub


Public Sub MigrarModelo(db As DAO.Database, rsTablas As Recordset, SQLdbTo As SQLdb)
    On Error GoTo HandleError
    Dim rs As Recordset, sSQL As String, sServer As String, sDBname As String, sUser As String, sPass As String, bOK As String
    Dim iOK As Integer, iErr As Integer
    'Set rs = CurrentDb.OpenRecordset("_MigrarTablas_", dbOpenSnapshot)
    'SQLdbTo.Server = "DESKTOP-K36ELVC\SQLEXPRESS"
    'SQLdbTo.DBname = "T4"
    'SQLdbTo.User = "userT4"
    'SQLdbTo.Password = "Passw0rdv"
    While Not rsTablas.EOF
        sSQL = GenerarTSQLEstructuraTabla(db, rsTablas("Tabla"))
        bOK = RunTSQL(sSQL, SQLdbTo.Server, SQLdbTo.DBname, SQLdbTo.User, SQLdbTo.Password)
        If bOK Then
            'CurrentDb.Execute "UPDATE _MigrarTablas_ SET Creada = True WHERE Tabla = '" & rs("Tabla") & "'", dbFailOnError
            iOK = iOK + 1
        Else
            iErr = iErr + 1
        End If
        rs.MoveNext
    Wend
    MsgBox iOK & " tablas creadas correctamente" & vbCrLf & iErr & " errores", vbInformation
HandleExit:
    Exit Sub
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Sub

Public Function SelectFolder(Optional initialFolder As String = "") As String
    On Error GoTo HandleError
    Dim dialogoCarpeta As FileDialog
    
    ' Crear una nueva instancia de la clase FileDialog con el tipo de selección de carpeta
    Set dialogoCarpeta = Application.FileDialog(msoFileDialogFolderPicker)
    If initialFolder = "" Then
        initialFolder = CurrentDb.Name
        initialFolder = Left(initialFolder, InStrRev(initialFolder, "\") - 1)
    End If
    dialogoCarpeta.InitialFileName = initialFolder
    ' Mostrar el cuadro de diálogo y comprobar si se seleccionó una carpeta
    If dialogoCarpeta.Show = -1 Then
        ' Si se seleccionó una carpeta, almacenarla en la variable
        SelectFolder = dialogoCarpeta.SelectedItems(1)
    Else
        ' Si se canceló la selección, mostrar un mensaje
    End If
    
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function

Public Function SelectFiles(sCarpetaInicial As String)
    On Error GoTo HandleError
    Dim dialogoFichero As FileDialog
    Dim ficheroSeleccionado As Variant
    Dim filtros As String
    Dim sResult As String
    
    ' Crear una nueva instancia de la clase FileDialog con el tipo de selección de archivo
    Set dialogoFichero = Application.FileDialog(msoFileDialogFilePicker)
    
    'Carpeta inicial
    dialogoFichero.InitialFileName = sCarpetaInicial
    
    ' Permitir seleccionar múltiples archivos
    dialogoFichero.AllowMultiSelect = True
    
    ' Establecer el título del cuadro de diálogo
    dialogoFichero.Title = "Selecciona uno o varios ficheros"
    
    ' Limpiar cualquier filtro existente
    dialogoFichero.Filters.Clear
    
    ' Agregar filtros de extensión de archivos (puedes añadir más si lo necesitas)
    dialogoFichero.Filters.Add "Bases de datos Access", "*.mdb; *.accdb"
    dialogoFichero.Filters.Add "Todos los archivos", "*.*"
    
    ' Mostrar el cuadro de diálogo
    If dialogoFichero.Show = -1 Then
        ' Iterar a través de los archivos seleccionados
        For Each ficheroSeleccionado In dialogoFichero.SelectedItems
            ' Mostrar la ruta del archivo seleccionado
            If InStr(ficheroSeleccionado, sCarpetaInicial) <> 1 Then
                MsgBox "Se deben seleccionar ficheros en la carpeta " & sCarpetaInicial & " o subcarpetas", vbExclamation
                GoTo HandleExit
            End If
            sResult = sResult & "," & Mid(ficheroSeleccionado, Len(sCarpetaInicial) + 1)
        Next ficheroSeleccionado
    Else
        ' Si se canceló la selección, mostrar un mensaje
        'MsgBox "No se seleccionó ningún fichero."
    End If
    If Len(sResult) > 1 Then sResult = Mid(sResult, 2)
    SelectFiles = sResult
    
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function

Public Function DimeTipoArreglo(Optional lIdArreglo As Long = 0) As Variant
    On Error GoTo HandleError
    Dim sRowSource As String
    sRowSource = "1;Cambio tamaño campo;2;Eliminar campo;3;Añadir campo;4;Eliminar índice;5;Añadir índice;6;Eliminar relación;7;Añadir relación"
    DimeTipoArreglo = fSelect(sRowSource, 2, 2, "0cm", "Seleccione tipo de arreglo", False)
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function

Public Function TablasDeFileName(lIdAccessDB As Long) As String
    On Error GoTo HandleError
    'Devuelve la lista de tablas de una fichero de base de datos Access que faltan de añadir
    Dim sFile As String, lIdMigration As Long, sCarpeta As String, db As DAO.Database, tdf As TableDef, sResult As String
    lIdMigration = Nz(DLookup("IdMigration", "tbAccessDBs", "Id = " & lIdAccessDB), 0)
    sCarpeta = Nz(DLookup("Carpeta", "tbMigrations", "Id = " & lIdMigration), "")
    sFile = sCarpeta & Nz(DLookup("[Path] & [FileName]", "tbAccessDBs", "Id = " & lIdAccessDB), "")
    On Error Resume Next
    Set db = OpenDatabase(sFile, , True)
    If Err <> 0 Then
        If Err = 3031 Then
            On Error GoTo HandleError
            Dim sPass As String
            sPass = InputBox("Contraseña de base de datos", "Contraseña")
            If sPass = "" Then GoTo HandleExit
            Set db = OpenDatabase(sFile, False, True, ";PWD=" & sPass)
        Else
            MsgBox "Error: " & Err & Err.Description
            GoTo HandleExit
        End If
    End If
    
    For Each tdf In db.TableDefs
        If IsNull(DLookup("Id", "tbTablas", "IdAccessDB = " & lIdAccessDB & " AND TableName = '" & tdf.Name & "'")) _
            And Not tdf.Name Like "MSys*" _
            And Len(tdf.Connect) = 0 Then
            sResult = sResult & ";" & tdf.Name
        End If
    Next tdf
    If Len(sResult) > 1 Then sResult = Mid(sResult, 2)
    TablasDeFileName = sResult
    
    
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function

Public Function TablasDeAccessDB(lIdAccessDB As Long) As String
    On Error GoTo HandleError
    'Devuelve la lista de tablas de una AccessDB
    Dim rs As Recordset, sResult As String
    Set rs = CurrentDb.OpenRecordset("SELECT TableName FROM tbTablas WHERE IdAccessDB = " & lIdAccessDB, dbOpenSnapshot)
    
    While Not rs.EOF
        sResult = sResult & ";" & rs("TableName")
        rs.MoveNext
    Wend
    If Len(sResult) > 1 Then sResult = Mid(sResult, 2)
    TablasDeAccessDB = sResult
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function



Public Function DimeFieldName(tdf As TableDef _
                   , Optional sDefault As String = "") As String
    On Error GoTo HandleError
    Dim sRowSource As String, fld As Field, sR As String
    For Each fld In tdf.Fields
        sRowSource = sRowSource & ";" & fld.Name
    Next fld
    sRowSource = Mid(sRowSource, 2) & ";Teclear Campo"
    sR = Nz(fSelect(sRowSource, 2, 1, "12cm", "Seleccione un campo", False, sDefault), "")
    If sR = "Teclear campo" Then
        sR = InputBox("Teclear nombre de campo", "Nombre de campo", sDefault)
    End If
    DimeFieldName = sR
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function

Public Function DimeTipoCampo(Optional sDefault As String = "") As String
    On Error GoTo HandleError
    Dim sRowSource As String, fld As Field
    sRowSource = "Texto;Número;Autonumérico;Fecha/Hora;Moneda;Sí/No"
    DimeTipoCampo = Nz(fSelect(sRowSource, 2, 1, "12cm", "Seleccione un tipo", False, sDefault), "")
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function

Public Function Dime_DBTipoCampo(sTipoCampo As String) As Integer
    On Error GoTo HandleError
    Dim sTipos As String, vTipos As Variant, dbTipos(5) As Integer, i As Integer
    sTipos = "Texto;Número;Autonumérico;Fecha/Hora;Moneda;Sí/No"
    vTipos = Split(sTipos, ";")
    dbTipos(0) = dbText: dbTipos(1) = dbLong: dbTipos(2) = dbLong: dbTipos(3) = dbDate: dbTipos(4) = dbCurrency: dbTipos(5) = dbBoolean:
    For i = LBound(vTipos) To UBound(vTipos)
        If sTipoCampo = vTipos(i) Then
            Exit For
        End If
    Next i
    If i <= UBound(vTipos) Then Dime_DBTipoCampo = dbTipos(i)
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function

Public Function DimeIndexName(tdf As TableDef _
                   , Optional sDefault As String = "") As String
    On Error GoTo HandleError
    Dim sRowSource As String, idx As Index, fld As Field, sFields As String
    For Each idx In tdf.Indexes
        sRowSource = sRowSource & ";" & idx.Name & "," & IIf(idx.Primary, "(PK)", "") & IIf(idx.Unique, "(U)", "")
        sFields = ""
        For Each fld In idx.Fields
            sFields = sFields & "+" & fld.Name
        Next fld
        sRowSource = sRowSource & "(" & Mid(sFields, 2) & ")"
    Next idx
    sRowSource = Mid(sRowSource, 2)
    DimeIndexName = Nz(fSelect(sRowSource, 2, 1, "12cm", "Seleccione un índice", False, sDefault), "")
    
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function

Public Function DimeRelacionName(db As Database, sTableName As String _
                      , Optional sDefault As String = "") As String
    'Obtiene una lista de relaciones en las que la tabla es la Tabla Principal
    On Error GoTo HandleError
    Dim rel As Relation, sRowSource As String, sRelacion As String
    For Each rel In db.Relations
        ' Verificar si es una relación de la tabla en cuestión
        If rel.Table = sTableName Then
            sRowSource = sRowSource & ";" & rel.Name & "," & rel.ForeignTable & "," & rel.Fields(0).Name
        End If
    Next rel
    sRowSource = Mid(sRowSource, 2)
    sRelacion = Nz(fSelect(sRowSource, 2, 1, "12cm", "Seleccione una relación", False, sDefault), "")
    DimeRelacionName = sRelacion
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume 'HandleExit
End Function


Public Function DimeRelacionName_ADO(sRutaDB As String, sTableName As String) As String
    'Obtiene una lista de relaciones en las que la tabla tiene Claves externas de Tablas de referencia y se selecciona una de la lista
    On Error GoTo HandleError
    Dim sRowSource As String, idx As Index, fld As Field, sFields As String
    Dim cat As Object
    Dim tbl As Object
    Dim key As ADOX.key
    Dim col As Object
    Dim strConexion As String
    
    ' Crear el objeto ADOX.Catalog
    Set cat = CreateObject("ADOX.Catalog")
    
    ' Cadena de conexión a la base de datos Access externa
    If sRutaDB Like "*.accdb" Then
        strConexion = "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=" & sRutaDB
    ElseIf sRutaDB Like "*.mdb" Then
        strConexion = "Provider=Microsoft.Jet.OLEDB.4.0;Data Source=" & sRutaDB
    Else
        MsgBox "El archivo de base de datos debe tener extensión .accdb o .mdb", vbExclamation
        GoTo HandleExit
    End If

    ' Conectar el catálogo a la base de datos externa
    cat.ActiveConnection = strConexion

    ' Buscar la tabla en el catálogo
    On Error Resume Next
    Set tbl = cat.Tables(sTableName)
    If Err <> 0 Then
        MsgBox "No se encontró la tabla " & sTableName & "en la base de datos " & sRutaDB, vbExclamation
        GoTo HandleExit
    End If
    On Error GoTo HandleError
 ' Recorrer las claves (keys) de la tabla
    For Each key In tbl.Keys
        ' Verificar si es una clave foránea (relación)
        If key.Type = 2 Then ' adKeyForeign = 2
            sRowSource = sRowSource & ";" & key.Name & " (" & key.RelatedTable
            sFields = ""
            For Each col In key.Columns
                sFields = sFields & "," & col.Name
            Next col
            sRowSource = sRowSource & "-->" & Mid(sFields, 2) & ")"
        End If
    Next key
    sRowSource = Mid(sRowSource, 2)
    DimeRelacionName_ADO = Nz(fSelect(sRowSource, 2, 1, "12cm", "Seleccione una relación", False), "")
    
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function


Public Function DimeRelacionFromTablaReferencia(lIdAccessDB As Long, sRutaDB As String, sReferenceTable As String)
    On Error GoTo HandleError
    Dim cat As Object ' ADOX Catalog
    Dim tbl As Object ' ADOX Table
    Dim key As Object ' ADOX Key
    Dim col As Object
    Dim strConexion As String
    Dim sRowSource As String, sField As String, sFields As String
    Dim tblActual As Object
    Dim rs As Recordset
    
    ' Crear el objeto ADOX.Catalog
    Set cat = CreateObject("ADOX.Catalog")
    
    ' Cadena de conexión a la base de datos Access externa
    If sRutaDB Like "*.accdb" Then
        strConexion = "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=" & sRutaDB
    ElseIf sRutaDB Like "*.mdb" Then
        strConexion = "Provider=Microsoft.Jet.OLEDB.4.0;Data Source=" & sRutaDB
    Else
        MsgBox "El archivo de base de datos debe tener extensión .accdb o .mdb", vbExclamation
        GoTo HandleExit
    End If


    ' Conectar el catálogo a la base de datos
    cat.ActiveConnection = strConexion
    Set rs = CurrentDb.OpenRecordset("SELECT TableName FROM tbTablas WHERE IdAccessDB = " & lIdAccessDB, dbOpenSnapshot)
    ' Recorrer todas las tablas de la base de datos
    For Each tblActual In cat.Tables
        ' Ignorar tablas que no están incluidas en la migración
        rs.FindFirst "TableName = '" & tblActual.Name & "'"
        If rs.NoMatch Then GoTo SiguienteTabla
        If tblActual.Name = sReferenceTable Then GoTo SiguienteTabla
        ' Recorrer las claves (keys) de cada tabla
        For Each key In tblActual.Keys
            ' Verificar si la clave es foránea (relación)
            If key.Type = 2 Then ' adKeyForeign = 2
                ' Verificar si la tabla de referencia es la tabla buscada
                If key.RelatedTable = sReferenceTable Then
                    sRowSource = sRowSource & ";" & key.Name & " (" & tblActual.Name
                    sFields = ""
                    For Each col In key.Columns
                        sFields = sFields & "," & col.Name
                    Next col
                    sRowSource = sRowSource & "-->" & Mid(sFields, 2) & ")"
                End If
            End If
        Next key

SiguienteTabla:
    Next tblActual
    sRowSource = Mid(sRowSource, 2)
    DimeRelacionFromTablaReferencia = Nz(fSelect(sRowSource, 2, 1, "12cm", "Seleccione una relación", False), "")
    
    
HandleExit:
    On Error Resume Next
    ' Liberar objetos
    Set key = Nothing
    Set tblActual = Nothing
    Set cat = Nothing
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume 'HandleExit
End Function


Public Function NuevoArreglo(iTipoArreglo As TipoArreglo, lIdAccessDB As Long, sTableName As String) As String
    'Dependiendo del Tipo de Arreglo solicita los parámetros necesarios para almacenarlos en el Campo Arreglo
    On Error GoTo HandleError
    Dim db As Database, tdf As TableDef, fls As Field
    Dim sCampo As String, iSize As Integer, Tamaño As String, sTipoCampo As String, sReturn As String _
        , sIndice As String, sIndexFields As String, sIndexPK As String, sIndexUnique As String _
        , sRutaDB As String, sRelacion As String, sRelatedTable As String, sRelatedField As String, iFieldType As Integer _
        , sOnUpdateCascade As String, sOnDeleteCascade, sRowSource As String
    Set db = GetDBfromFile(lIdAccessDB, , , , , sRutaDB)
    Set tdf = db.TableDefs(sTableName)
    Select Case iTipoArreglo
        Case TipoArreglo.Cambio_tamaño_campo
            sCampo = Nz(DimeFieldName(tdf), "")
            If sCampo = "" Then GoTo HandleExit
            iSize = tdf.Fields(sCampo).Size
            Tamaño = InputBox("Nuevo tamaño del campo", "Tamaño", CStr(iSize))
            If Not IsNumeric(Tamaño) Then
                MsgBox "Debe ser un número", vbExclamation
                GoTo HandleExit
            End If
            iSize = CInt(Tamaño)
            sReturn = sCampo & "," & iSize
        Case TipoArreglo.Eliminar_campo
            sCampo = Nz(DimeFieldName(tdf), "")
            If sCampo = "" Then GoTo HandleExit
            sReturn = sCampo
        Case TipoArreglo.Añadir_campo
            sCampo = InputBox("Nuevo campo", "Nuevo campo", "NombreCampo")
            If sCampo = "" Then GoTo HandleExit
            sTipoCampo = Nz(DimeTipoCampo(), "")
            If sTipoCampo = "" Then GoTo HandleExit
            If sTipoCampo = "Texto" Then
                Tamaño = InputBox("Tamaño del campo", "Tamaño", CStr(255))
                If Tamaño = "" Then GoTo HandleExit
                If Not IsNumeric(Tamaño) Then
                    MsgBox "Debe ser un número", vbExclamation
                    GoTo HandleExit
                End If
                iSize = CInt(Tamaño)
            End If
            sReturn = sCampo & "," & sTipoCampo & IIf(sTipoCampo = "Texto", "," & iSize, "")
        Case TipoArreglo.Eliminar_indice
            sIndice = Nz(DimeIndexName(tdf), "")
            If sIndice = "" Then GoTo HandleExit
            sReturn = sIndice
        Case TipoArreglo.Añadir_indice
CampoIndice:
            sCampo = Nz(DimeFieldName(tdf), "")
            If sCampo = "" Then
                If sIndexFields = "" Then GoTo HandleExit
                sIndexFields = Mid(sIndexFields, 2)
                sIndice = Mid(sIndice, 2)
            Else
                sIndexFields = sIndexFields & ";" & sCampo
                sIndice = sIndice & "_" & sCampo
                GoTo CampoIndice
            End If
            sIndexPK = Nz(fSelect("Sí;No", 2, 1, "6cm", "Primary Key?", False), "")
            If sIndexPK = "" Then GoTo HandleExit
            If sIndexPK = "No" Then
                sIndexUnique = Nz(fSelect("Sí;No", 2, 1, "6cm", "Unique?", False), "")
                If sIndexUnique = "" Then GoTo HandleExit
            Else
                sIndice = "PrimaryKey"
            End If
            sReturn = sIndice & "," & IIf(sIndexPK = "Sí", "S", "N") & "," & IIf(sIndexUnique = "Sí", "S", "N") & "," & sIndexFields
        Case TipoArreglo.Eliminar_relacion
            'sRelacion = Nz(DimeRelacionFromTablaReferencia(lIdAccessDB, sRutaDB, sTableName), "")
            sRelacion = Nz(DimeRelacionName(db, sTableName), "")
            If sRelacion = "" Then GoTo HandleExit
            sReturn = sRelacion
        Case TipoArreglo.Añadir_relacion
            sCampo = Nz(DimeFieldName(tdf), "")
            If sCampo = "" Then GoTo HandleExit
            iFieldType = tdf(sCampo).Type
            sRowSource = TablasDeAccessDB(lIdAccessDB)
            sRelatedTable = Nz(fSelect(sRowSource, 2, 1, "20", "Seleccione tabla relacionada", False), "")
            If sRelatedTable = "" Then GoTo HandleExit
            If sRelatedTable = sTableName Then
                MsgBox "No se puede relacionar una tabla consigo misma", vbExclamation
                GoTo HandleExit
            End If
            
            Set tdf = db.TableDefs(sRelatedTable)
            sRelatedField = Nz(DimeFieldName(tdf), "")
            If sRelatedField = "" Then GoTo HandleExit
            If iFieldType <> tdf(sRelatedField).Type Then
                MsgBox "Los tipos de los campos a relacionar no son iguales", vbExclamation
                GoTo HandleExit
            End If
            sOnUpdateCascade = Nz(fSelect("Sí;No", 2, 1, "6cm", "Actualizar en cascada?", False), "")
            If sOnUpdateCascade = "" Then GoTo HandleExit
            sOnDeleteCascade = Nz(fSelect("Sí;No", 2, 1, "6cm", "Eliminar en cascada?", False), "")
            If sOnDeleteCascade = "" Then GoTo HandleExit
            'Arreglo = NombreRelacion,CampoFK, Reference_Table, Reference_Field, OnUpdateCascadeSN, OnDeleteCascadeSN
            sRelacion = sTableName & "_" & sCampo & "__" & sRelatedTable & "_" & sRelatedField
            sReturn = sRelacion & "," & sCampo & "," & sRelatedTable & "," & sRelatedField & "," & IIf(sOnUpdateCascade = "Sí", "S", "N") & "," & IIf(sOnDeleteCascade = "Sí", "S", "N")
            
            
    End Select
    NuevoArreglo = sReturn
    
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume HandleExit
End Function

Public Function EditaArreglo(lIdArreglo As Long, lIdMigration As Long) As String
    On Error GoTo HandleError
    Dim iTipoArreglo As TipoArreglo, lIdAccessDB As Long, sTableName As String, sArreglo As String, vArreglo As Variant, i As Integer
    iTipoArreglo = DLookup("IdTipoArreglo", "tbTablasArreglos", "Id = " & lIdArreglo)
    sTableName = DLookup("TableName", "tbTablasArreglos", "Id = " & lIdArreglo)
    lIdAccessDB = DLookup("Id", "qAccessDBs_Tablas", "IdMigration = " & lIdMigration & " AND TableName = '" & sTableName & "'")
    sArreglo = DLookup("Arreglo", "tbTablasArreglos", "Id = " & lIdArreglo)
    vArreglo = Split(sArreglo, ",")
    Dim db As Database, tdf As TableDef, fls As Field
    Dim sCampo As String, iSize As Integer, Tamaño As String, sTipoCampo As String, sReturn As String _
        , sIndice As String, sIndexFields As String, sIndexPK As String, sIndexUnique As String _
        , sRutaDB As String, sRelacion As String, sRelatedTable As String, sRelatedField As String, iFieldType As Integer _
        , sOnUpdateCascade As String, sOnDeleteCascade, sRowSource As String
    Set db = GetDBfromFile(lIdAccessDB, , , , , sRutaDB)
    Set tdf = db.TableDefs(sTableName)
    Select Case iTipoArreglo
        Case TipoArreglo.Cambio_tamaño_campo
            sCampo = vArreglo(0)
            iSize = vArreglo(1)
            sCampo = Nz(DimeFieldName(tdf, sCampo), "")
            If sCampo = "" Then GoTo HandleExit
            'iSize = tdf.Fields(sCampo).Size
            iSize = vArreglo(1)
            Tamaño = InputBox("Nuevo tamaño del campo", "Tamaño", CStr(iSize))
            If Not IsNumeric(Tamaño) Then
                MsgBox "Debe ser un número", vbExclamation
                GoTo HandleExit
            End If
            iSize = CInt(Tamaño)
            sReturn = sCampo & "," & iSize
        Case TipoArreglo.Eliminar_campo
            sCampo = vArreglo(0)
            sCampo = Nz(DimeFieldName(tdf, sCampo), "")
            If sCampo = "" Then GoTo HandleExit
            sReturn = sCampo
        Case TipoArreglo.Añadir_campo
            sCampo = vArreglo(0)
            sTipoCampo = vArreglo(1)
            If sCampo = "Texto" Then Tamaño = vArreglo(2)
            sCampo = InputBox("Nuevo campo", "Nuevo campo", sCampo)
            If sCampo = "" Then GoTo HandleExit
            sTipoCampo = Nz(DimeTipoCampo(sTipoCampo), "")
            If sTipoCampo = "" Then GoTo HandleExit
            If sTipoCampo = "Texto" Then
                Tamaño = InputBox("Tamaño del campo", "Tamaño", CStr(Tamaño))
                If Tamaño = "" Then GoTo HandleExit
                If Not IsNumeric(Tamaño) Then
                    MsgBox "Debe ser un número", vbExclamation
                    GoTo HandleExit
                End If
                iSize = CInt(Tamaño)
            End If
            sReturn = sCampo & "," & sTipoCampo & IIf(sTipoCampo = "Texto", "," & iSize, "")
        Case TipoArreglo.Eliminar_indice
            sIndice = sArreglo
            sIndice = Nz(DimeIndexName(tdf, sIndice), "")
            If sIndice = "" Then GoTo HandleExit
            sReturn = sIndice
        Case TipoArreglo.Añadir_indice
            Dim vFields As Variant
            vFields = Split(vArreglo(3), ";")
            i = 0
CampoIndice:
            If i <= UBound(vFields) Then
                sCampo = Nz(DimeFieldName(tdf, CStr(vFields(i))), "")
            Else
                sCampo = Nz(DimeFieldName(tdf), "")
            End If
            If sCampo = "" Then
                If sIndexFields = "" Then GoTo HandleExit
                sIndexFields = Mid(sIndexFields, 2)
                sIndice = Mid(sIndice, 2)
            Else
                sIndexFields = sIndexFields & ";" & sCampo
                sIndice = sIndice & "_" & sCampo
                i = i + 1
                GoTo CampoIndice
            End If
            sIndexPK = IIf(vArreglo(1) = "S", "Sí", "No")
            sIndexPK = Nz(fSelect("Sí;No", 2, 1, "6cm", "Primary Key?", False, sIndexPK), "")
            If sIndexPK = "" Then GoTo HandleExit
            If sIndexPK = "No" Then
                sIndexUnique = IIf(vArreglo(2) = "S", "Sí", "No")
                sIndexUnique = Nz(fSelect("Sí;No", 2, 1, "6cm", "Unique?", False, sIndexUnique), "")
                If sIndexUnique = "" Then GoTo HandleExit
            Else
                sIndice = "PrimaryKey"
            End If
            sReturn = sIndice & "," & IIf(sIndexPK = "Sí", "S", "N") & "," & IIf(sIndexUnique = "Sí", "S", "N") & "," & sIndexFields
        Case TipoArreglo.Eliminar_relacion
            'sRelacion = Nz(DimeRelacionFromTablaReferencia(lIdAccessDB, sRutaDB, sTableName), "")
            sRelacion = sArreglo
            sRelacion = Nz(DimeRelacionName(db, sTableName, sRelacion), "")
            If sRelacion = "" Then GoTo HandleExit
            sReturn = sRelacion
        Case TipoArreglo.Añadir_relacion
            sCampo = vArreglo(1)
            sCampo = Nz(DimeFieldName(tdf, sCampo), "")
            If sCampo = "" Then GoTo HandleExit
            iFieldType = tdf(sCampo).Type
            sRowSource = TablasDeAccessDB(lIdAccessDB)
            sRelatedTable = vArreglo(2)
            sRelatedTable = Nz(fSelect(sRowSource, 2, 1, "20", "Seleccione tabla relacionada", False, sRelatedTable), "")
            If sRelatedTable = "" Then GoTo HandleExit
            If sRelatedTable = sTableName Then
                MsgBox "No se puede relacionar una tabla consigo misma", vbExclamation
                GoTo HandleExit
            End If
            
            Set tdf = db.TableDefs(sRelatedTable)
            sRelatedField = vArreglo(3)
            sRelatedField = Nz(DimeFieldName(tdf, sRelatedField), "")
            If sRelatedField = "" Then GoTo HandleExit
            If iFieldType <> tdf(sRelatedField).Type Then
                MsgBox "Los tipos de los campos a relacionar no son iguales", vbExclamation
                GoTo HandleExit
            End If
            sOnUpdateCascade = IIf(vArreglo(4) = "S", "Sí", "No")
            sOnUpdateCascade = Nz(fSelect("Sí;No", 2, 1, "6cm", "Actualizar en cascada?", False, sOnUpdateCascade), "")
            If sOnUpdateCascade = "" Then GoTo HandleExit
            sOnDeleteCascade = IIf(vArreglo(5) = "S", "Sí", "No")
            sOnDeleteCascade = Nz(fSelect("Sí;No", 2, 1, "6cm", "Eliminar en cascada?", False, sOnDeleteCascade), "")
            If sOnDeleteCascade = "" Then GoTo HandleExit
            'Arreglo = NombreRelacion,CampoFK, Reference_Table, Reference_Field, OnUpdateCascadeSN, OnDeleteCascadeSN
            sRelacion = sTableName & "_" & sCampo & "__" & sRelatedTable & "_" & sRelatedField
            sReturn = sRelacion & "," & sCampo & "," & sRelatedTable & "," & sRelatedField & "," & IIf(sOnUpdateCascade = "Sí", "S", "N") & "," & IIf(sOnDeleteCascade = "Sí", "S", "N")
            
            
    End Select
    EditaArreglo = sReturn
    
HandleExit:
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume 'HandleExit
End Function

Public Function TipoArregloTXT(iTipoArreglo As TipoArreglo) As String
    Dim sR As String
    Select Case iTipoArreglo
        Case 1: sR = "Cambio_tamaño_campo"
        Case 2: sR = "Eliminar_campo"
        Case 3: sR = "Añadir_campo"
        Case 4: sR = "Eliminar_indice"
        Case 5: sR = "Añadir_indice"
        Case 6: sR = "Eliminar_relacion"
        Case 7: sR = "Añadir_relacion"
        Case Else: sR = "¿?"
    End Select
    TipoArregloTXT = sR
End Function

Public Function RunArregloTabla(lIdTablaArreglo As Long, lIdMigration As Long) As Boolean
    On Error GoTo HandleError
    Dim iTipoArreglo As TipoArreglo, sArreglo As String
    iTipoArreglo = Nz(DLookup("IdTipoArreglo", "tbTablasArreglos", "Id = " & lIdTablaArreglo), 0)
    sArreglo = Nz(DLookup("Arreglo", "tbTablasArreglos", "Id = " & lIdTablaArreglo), "")
    If iTipoArreglo = 0 Or sArreglo = "" Then
        MsgBox "No se encontró el Tipo o la definiciçon del arreglo", vbExclamation
        GoTo HandleExit
    End If
    
    Dim lIdTabla As Long, sTableName As String, lIdAccessDB As Long, sFileName As String, sRutaDB As String, db As Database, tdf As DAO.TableDef, fld As Field, idx As DAO.Index
    Dim sFieldName As String, iTipoDato As Integer, iSize As Integer, vArreglo As Variant, strConexion As String, sSQL As String, cnn As Object, sIndexName As String, bPrimaryKey As Boolean, bUnique As Boolean
    Dim sFields As String, i As Integer, vFields As Variant
    Dim sRelacion As String, sFK_Field As String, sRef_Table As String, sRef_Field As String, bOnUpdateCascade As Boolean, bOnDeleteCascade As Boolean, rel As DAO.Relation, sForeignTable As String
    'lIdTabla = DLookup("IdTabla", "tbTablasArreglos", "Id = " & lIdTablaArreglo)
    sTableName = DLookup("TableName", "tbTablasArreglos", "Id = " & lIdTablaArreglo)
    sFileName = DLookup("FileName", "tbTablasArreglos", "Id = " & lIdTablaArreglo)
    lIdAccessDB = DLookup("Id", "tbAccessDBs", "FileName = '" & sFileName & "' AND IdMigration = " & lIdMigration)
    Set db = GetDBfromFile(lIdAccessDB, , , , , sRutaDB)
    Set tdf = db.TableDefs(sTableName)
    vArreglo = Split(sArreglo, ",")
    
    If sRutaDB Like "*.accdb" Then
        strConexion = "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=" & sRutaDB
    ElseIf sRutaDB Like "*.mdb" Then
        strConexion = "Provider=Microsoft.Jet.OLEDB.4.0;Data Source=" & sRutaDB
    Else
        MsgBox "El archivo de base de datos debe tener extensión .accdb o .mdb", vbExclamation
        GoTo HandleExit
    End If
    
    Select Case iTipoArreglo
        Case TipoArreglo.Cambio_tamaño_campo 'utilizamos ADO
            sFieldName = vArreglo(0)
            iSize = vArreglo(1)
            Set cnn = CreateObject("ADODB.Connection")
            cnn.Open strConexion
            ' Crear la consulta SQL para modificar el tamaño del campo
            sSQL = "ALTER TABLE " & sTableName & " ALTER COLUMN " & sFieldName & " TEXT(" & iSize & ")"
            ' Ejecutar la consulta
            cnn.Execute sSQL
            ' Cerrar la conexión
            
        Case TipoArreglo.Eliminar_campo 'utilizamos DAO
            sFieldName = vArreglo(0)
            tdf.Fields.Delete sFieldName
        Case TipoArreglo.Añadir_campo
            sFieldName = vArreglo(0)
            iTipoDato = Dime_DBTipoCampo(CStr(vArreglo(1)))
            If iTipoDato = dbText Then
                iSize = vArreglo(2)
                Set fld = tdf.CreateField(sFieldName, iTipoDato, iSize)
            Else
                Set fld = tdf.CreateField(sFieldName, iTipoDato)
            End If
            tdf.Fields.Append fld
        Case TipoArreglo.Eliminar_indice
            sIndexName = vArreglo(0)
            tdf.Indexes.Delete sIndexName
        Case TipoArreglo.Añadir_indice
            sIndexName = vArreglo(0)
            bPrimaryKey = vArreglo(1) = "S"
            bUnique = vArreglo(2) = "S"
            For i = 3 To UBound(vArreglo)
                sFields = sFields & "," & vArreglo(i)
            Next i
            sFields = Mid(sFields, 2)
            vFields = Split(sFields, ";")
             ' Crear un nuevo índice
            Set idx = tdf.CreateIndex(sIndexName)
            For i = 0 To UBound(vFields)
                ' Agregar el campo que será indexado
                idx.Fields.Append idx.CreateField(vFields(i))
            Next i
            ' Opcional: establecer si el índice es único
            If bPrimaryKey Then idx.Primary = True
            If bUnique Then idx.Unique = True
            ' Añadir el índice a la tabla
            tdf.Indexes.Append idx
        Case TipoArreglo.Eliminar_relacion
            sRelacion = vArreglo(0)
            sForeignTable = vArreglo(1)
            Set cnn = CreateObject("ADODB.Connection")
            cnn.Open strConexion
            ' Crear la consulta SQL para modificar el tamaño del campo
            sSQL = "ALTER TABLE " & sForeignTable & " DROP CONSTRAINT " & sRelacion
            ' Ejecutar la consulta
            cnn.Execute sSQL
            'db.Relations.Delete sRelacion
        Case TipoArreglo.Añadir_relacion 'Arreglo = NombreRelacion,CampoFK, Reference_Table, Reference_Field, OnUpdateCascadeSN, OnDeleteCascadeSN
            sRelacion = vArreglo(0)
            sFK_Field = vArreglo(1)
            sRef_Table = vArreglo(2)
            sRef_Field = vArreglo(3)
            bOnUpdateCascade = vArreglo(4) = "S"
            bOnDeleteCascade = vArreglo(5) = "S"
            ' Crear la nueva relación
            Set rel = db.CreateRelation(sRelacion, sTableName, sRef_Table)
        
            ' Agregar los campos que definen la relación
            rel.Fields.Append rel.CreateField(sFK_Field)
            rel.Fields(sFK_Field).ForeignName = sRef_Field
        
            ' Habilitar la integridad referencial
            'rel.Attributes = dbRelationUnique '
            If bOnUpdateCascade Then rel.Attributes = rel.Attributes + dbRelationUpdateCascade
            If bOnDeleteCascade Then rel.Attributes = rel.Attributes + dbRelationDeleteCascade
        
            ' Añadir la relación a la base de datos
            Debug.Print "Table: " & rel.Table, "Field: " & rel.Fields(0).Name
            Debug.Print "ForeignTable: " & rel.ForeignTable, "ForeignField: " & rel.Fields(0).ForeignName
            db.Relations.Append rel
    End Select
    RunArregloTabla = True
    
    

HandleExit:
    On Error Resume Next
 ' Cerrar los objetos DAO
    Set fld = Nothing
    Set tdf = Nothing
    Set db = Nothing
 ' Cerrar los objetos ADO
    cnn.Close
    Set cnn = Nothing
    Exit Function
HandleError:
    MsgBox Err.Description
    Resume ' HandleExit
End Function

Function papa()
    Dim db As Database, rel As Relation
    Set db = OpenDatabase("E:\_DOCS1_\_Comercios_Gestion_Actividades\TOCATEJA\A2SS\T4\T4_Art.mdb", , True)
    For Each rel In db.Relations
        Debug.Print rel.Name, rel.Fields(0).Name, rel.ForeignTable ', rel.ForeignFields(0)
    Next rel
End Function